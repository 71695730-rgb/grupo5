#include <iostream>
#include <string>
#include <limits>
using namespace std;

// Estructura que representa un proceso en el sistema
struct Proceso {
    int pid;
    string nombre;
    int prioridad;
    string estado;
    int tiempoCPU;
};

// Nodo genérico para listas enlazadas (usado en lista, cola y pila)
struct Nodo {
    Proceso *proc;
    Nodo *sig;
    Nodo(Proceso *p) { proc = p; sig = NULL; }
};

// Lista enlazada para gestionar procesos (operaciones: insertar, eliminar, buscar, mostrar)
struct ListaProcesos {
    Nodo *inicio;
    ListaProcesos() { inicio = NULL; }

    // Busca un proceso por PID en la lista
    Nodo* buscarPorPID(int pid) {
        Nodo *actual = inicio;
        while (actual != NULL) {
            if (actual->proc->pid == pid) return actual;
            actual = actual->sig;
        }
        return NULL;
    }

    // Inserta un proceso al final de la lista
    void insertarProceso(Proceso *p) {
        Nodo *nuevo = new Nodo(p);
        if (inicio == NULL) inicio = nuevo;
        else {
            Nodo *aux = inicio;
            while (aux->sig != NULL) aux = aux->sig;
            aux->sig = nuevo;
        }
    }

    // Elimina un proceso por PID de la lista
    bool eliminarProceso(int pid) {
        if (inicio == NULL) return false;
        if (inicio->proc->pid == pid) {
            Nodo *tmp = inicio;
            inicio = inicio->sig;
            delete tmp->proc;
            delete tmp;
            return true;
        }
        Nodo *ant = inicio, *act = inicio->sig;
        while (act != NULL) {
            if (act->proc->pid == pid) {
                ant->sig = act->sig;
                delete act->proc;
                delete act;
                return true;
            }
            ant = act;
            act = act->sig;
        }
        return false;
    }

    // Muestra todos los procesos en la lista
    void mostrarProcesos() {
        cout << "\n--- PROCESOS REGISTRADOS ---\n";
        if (inicio == NULL) { cout << "No hay procesos.\n"; return; }
        Nodo *aux = inicio;
        while (aux != NULL) {
            Proceso *p = aux->proc;
            cout << "PID: " << p->pid
                 << " | Nombre: " << p->nombre
                 << " | Prioridad: " << p->prioridad
                 << " | Estado: " << p->estado
                 << " | TiempoCPU: " << p->tiempoCPU << " ms\n";
            aux = aux->sig;
        }
    }
};

// Cola de prioridad para planificar procesos en CPU (operaciones: encolar, desencolar, mostrar)
struct ColaPrioridad {
    Nodo *cabeza;
    ColaPrioridad() { cabeza = NULL; }

    // Verifica si la cola está vacía
    bool vacia() { return cabeza == NULL; }

    // Verifica si un PID está en la cola
    bool estaEnCola(int pid) {
        Nodo *aux = cabeza;
        while (aux != NULL) {
            if (aux->proc->pid == pid) return true;
            aux = aux->sig;
        }
        return false;
    }

    // Encola un proceso según su prioridad (menor prioridad primero)
    void encolar(Proceso *p) {
        Nodo *nuevo = new Nodo(p);
        if (cabeza == NULL) { cabeza = nuevo; return; }
        if (p->prioridad < cabeza->proc->prioridad) {
            nuevo->sig = cabeza;
            cabeza = nuevo;
            return;
        }
        Nodo *ant = cabeza, *act = cabeza->sig;
        while (act != NULL && act->proc->prioridad <= p->prioridad) {
            ant = act;
            act = act->sig;
        }
        ant->sig = nuevo;
        nuevo->sig = act;
    }

    // Desencola el proceso de mayor prioridad (menor número)
    bool desencolar(Proceso *&p) {
        if (cabeza == NULL) return false;
        Nodo *tmp = cabeza;
        p = cabeza->proc;
        cabeza = cabeza->sig;
        delete tmp;
        return true;
    }

    // Muestra la cola de planificación
    void mostrarCola() {
        cout << "\n--- COLA DE PLANIFICACIÓN ---\n";
        if (cabeza == NULL) { cout << "Cola vacía.\n"; return; }
        Nodo *aux = cabeza;
        while (aux != NULL) {
            Proceso *pp = aux->proc;
            cout << "PID: " << pp->pid
                 << " | Nombre: " << pp->nombre
                 << " | Prioridad: " << pp->prioridad
                 << " | Estado: " << pp->estado << "\n";
            aux = aux->sig;
        }
    }

    // Elimina un proceso por PID de la cola
    bool eliminarPorPID(int pid) {
        if (cabeza == NULL) return false;
        if (cabeza->proc->pid == pid) {
            Nodo *tmp = cabeza;
            cabeza = cabeza->sig;
            delete tmp;
            return true;
        }
        Nodo *ant = cabeza, *act = cabeza->sig;
        while (act != NULL) {
            if (act->proc->pid == pid) {
                ant->sig = act->sig;
                delete act;
                return true;
            }
            ant = act;
            act = act->sig;
        }
        return false;
    }
};

// Estructura para bloques de memoria asignados
struct BloqueMem {
    Proceso *proc;
    int tamanio;
    BloqueMem *sig;
    BloqueMem(Proceso *p, int t) { proc = p; tamanio = t; sig = NULL; }
};

// Pila para gestionar asignación de memoria (operaciones: asignar, liberar, mostrar)
struct PilaMemoria {
    BloqueMem *tope;
    PilaMemoria() { tope = NULL; }

    // Verifica si la pila está vacía
    bool vacia() { return tope == NULL; }

    // Asigna un bloque de memoria a un proceso (push)
    void asignarMemoria(Proceso *proc, int tamanio) {
        BloqueMem *nuevo = new BloqueMem(proc, tamanio);
        nuevo->sig = tope;
        tope = nuevo;
        cout << "Asignado bloque " << tamanio << " al PID " << proc->pid << ".\n";
    }

    // Libera el bloque de memoria en el tope (pop)
    bool liberarMemoria() {
        if (tope == NULL) { cout << "Pila vacía.\n"; return false; }
        BloqueMem *tmp = tope;
        cout << "Liberando bloque PID " << tmp->proc->pid << " | Tamaño: " << tmp->tamanio << "\n";
        tope = tope->sig;
        delete tmp;
        return true;
    }

    // Muestra el estado actual de la memoria
    void mostrarEstado() {
        cout << "\n--- ESTADO DE MEMORIA ---\n";
        if (tope == NULL) { cout << "No hay memoria asignada.\n"; return; }
        BloqueMem *aux = tope; int i = 0;
        while (aux != NULL) {
            cout << "[" << i << "] PID: " << aux->proc->pid
                 << " | Nombre: " << aux->proc->nombre
                 << " | Tamaño: " << aux->tamanio << "\n";
            aux = aux->sig; i++;
        }
    }

    // Elimina todos los bloques de memoria de un PID específico
    void eliminarBloquesDePID(int pid) {
        if (tope == NULL) return;
        BloqueMem *tempTop = NULL;
        while (tope != NULL) {
            BloqueMem *cur = tope;
            tope = tope->sig;
            if (cur->proc->pid == pid) delete cur;
            else { cur->sig = tempTop; tempTop = cur; }
        }
        BloqueMem *recon = NULL;
        while (tempTop != NULL) {
            BloqueMem *cur = tempTop;
            tempTop = tempTop->sig;
            cur->sig = recon;
            recon = cur;
        }
        tope = recon;
    }
};

// Función auxiliar para leer un entero positivo con validación
int leerEnteroPositivo(const char *mensaje) {
    int x;
    while (true) {
        cout << mensaje;
        if ((cin >> x) && x > 0) {
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            return x;
        } else {
            cout << "Entrada inválida.\n";
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
    }
    return 0; // Evita advertencias en Dev-C++
}

// Función para pausar y esperar ENTER
void presionarEnter() {
    cout << "\nPresione ENTER para continuar...";
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
}

// Muestra el menú principal
void mostrarMenuPrincipal() {
    cout << "\n===============================================\n";
    cout << "  SISTEMA DE GESTION DE PROCESOS\n";
    cout << "===============================================\n";
    cout << "1) Gestor de Procesos (Lista)\n";
    cout << "2) Planificador de CPU (Cola)\n";
    cout << "3) Gestor de Memoria (Pila)\n";
    cout << "4) Mostrar todo\n";
    cout << "5) Salir\n";
    cout << "Seleccione opción: ";
}

// Submenú para gestionar procesos (usa lista enlazada)
void submenuGestorProcesos(ListaProcesos &lista, ColaPrioridad &cola, PilaMemoria &mem) {
    int op = -1;
    while (op != 0) {
        cout << "\n--- GESTOR DE PROCESOS ---\n";
        cout << "1) Insertar\n2) Eliminar\n3) Buscar\n4) Mostrar\n0) Volver\nOpción: ";
        if (!(cin >> op)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); continue; }
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        if (op == 1) {
            int pid;
            while (true) {
                pid = leerEnteroPositivo("PID: ");
                if (lista.buscarPorPID(pid) != NULL) cout << "PID existente.\n";
                else break;
            }
            string nombre;
            cout << "Nombre: "; getline(cin, nombre);
            int prioridad = leerEnteroPositivo("Prioridad (1-10): ");
            int tiempo = leerEnteroPositivo("Tiempo CPU: ");
            Proceso *p = new Proceso{pid, nombre, prioridad, "Listo", tiempo};
            lista.insertarProceso(p);
            cout << "Proceso registrado.\n";
            presionarEnter();
        }
        else if (op == 2) {
            int pid = leerEnteroPositivo("PID a eliminar: ");
            cola.eliminarPorPID(pid);
            mem.eliminarBloquesDePID(pid);
            if (lista.eliminarProceso(pid)) cout << "Proceso eliminado.\n";
            else cout << "No encontrado.\n";
            presionarEnter();
        }
        else if (op == 3) {
            int pid = leerEnteroPositivo("PID a buscar: ");
            Nodo *n = lista.buscarPorPID(pid);
            if (n != NULL) cout << "PID " << pid << " encontrado: " << n->proc->nombre << "\n";
            else cout << "No encontrado.\n";
            presionarEnter();
        }
        else if (op == 4) { lista.mostrarProcesos(); presionarEnter(); }
    }
}

// Submenú para planificar CPU (usa cola de prioridad)
void submenuPlanificador(ListaProcesos &lista, ColaPrioridad &cola, PilaMemoria &mem) {
    int op = -1;
    while (op != 0) {
        cout << "\n--- PLANIFICADOR DE CPU ---\n";
        cout << "1) Encolar\n2) Desencolar y ejecutar\n3) Mostrar cola\n4) Verificar PID\n0) Volver\nOpción: ";
        if (!(cin >> op)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); continue; }
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        if (op == 1) {
            int pid = leerEnteroPositivo("PID a encolar: ");
            Nodo *n = lista.buscarPorPID(pid);
            if (n == NULL) cout << "No existe.\n";
            else if (cola.estaEnCola(pid)) cout << "Ya está en cola.\n";
            else { cola.encolar(n->proc); cout << "Encolado.\n"; }
            presionarEnter();
        }
        else if (op == 2) {
            Proceso *pExec = NULL;
            if (!cola.desencolar(pExec)) cout << "Cola vacía.\n";
            else {
                cout << "Ejecutando " << pExec->nombre << "...\n";
                pExec->estado = "Finalizado";
                cout << "Finalizado.\n";
            }
            presionarEnter();
        }
        else if (op == 3) { cola.mostrarCola(); presionarEnter(); }
        else if (op == 4) {
            int pid = leerEnteroPositivo("PID: ");
            cout << (cola.estaEnCola(pid) ? "Está en cola.\n" : "No está en cola.\n");
            presionarEnter();
        }
    }
}

// Submenú para gestionar memoria (usa pila)
void submenuMemoria(ListaProcesos &lista, ColaPrioridad &cola, PilaMemoria &mem) {
    int op = -1;
    while (op != 0) {
        cout << "\n--- GESTOR DE MEMORIA ---\n";
        cout << "1) Asignar\n2) Liberar\n3) Mostrar\n4) Eliminar PID\n0) Volver\nOpción: ";
        if (!(cin >> op)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); continue; }
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        if (op == 1) {
            int pid = leerEnteroPositivo("PID: ");
            Nodo *n = lista.buscarPorPID(pid);
            if (n == NULL) cout << "No existe.\n";
            else {
                int tam = leerEnteroPositivo("Tamaño: ");
                mem.asignarMemoria(n->proc, tam);
            }
            presionarEnter();
        }
        else if (op == 2) { mem.liberarMemoria(); presionarEnter(); }
        else if (op == 3) { mem.mostrarEstado(); presionarEnter(); }
        else if (op == 4) {
            int pid = leerEnteroPositivo("PID: ");
            mem.eliminarBloquesDePID(pid);
            cout << "Bloques eliminados.\n";
            presionarEnter();
        }
    }
}

// Muestra el estado de todos los componentes (lista, cola, pila)
void mostrarTodo(ListaProcesos &lista, ColaPrioridad &cola, PilaMemoria &mem) {
    lista.mostrarProcesos();
    cola.mostrarCola();
    mem.mostrarEstado();
}

// Función principal: maneja el menú y la lógica general
int main() {
    ListaProcesos lista;
    ColaPrioridad cola;
    PilaMemoria mem;
    int opcion = -1;
    while (opcion != 5) {
        mostrarMenuPrincipal();
        if (!(cin >> opcion)) { cin.clear(); cin.ignore(numeric_limits<streamsize>::max(), '\n'); continue; }
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        if (opcion == 1) submenuGestorProcesos(lista, cola, mem);
        else if (opcion == 2) submenuPlanificador(lista, cola, mem);
        else if (opcion == 3) submenuMemoria(lista, cola, mem);
        else if (opcion == 4) { mostrarTodo(lista, cola, mem); presionarEnter(); }
        else if (opcion == 5) {
            cout << "Saliendo...\n";
            while (!mem.vacia()) mem.liberarMemoria();
            while (lista.inicio != NULL) lista.eliminarProceso(lista.inicio->proc->pid);
        }
    }
    return 0;
}
